<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acoustic Measurement Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
        }
        
        .control-group h3 {
            color: #555;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        select, input, button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background: #e8f4f8;
            color: #0066cc;
            text-align: center;
        }
        
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .result-card {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .result-card h4 {
            color: #444;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .result-value {
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .result-details {
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
            background: #fafafa;
        }
        
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
        }
        
        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîä Acoustic Measurement Tool</h1>
        <p class="subtitle">Measure RT60, Comb Filtering, and Time Delay for Loudspeaker Systems</p>
        
        <div class="warning">
            ‚ö†Ô∏è <strong>Setup Instructions:</strong> Position your measurement microphone at the listening position. Ensure room is quiet before starting measurements.
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üì° Signal Generator</h3>
                <select id="signalType">
                    <option value="sweep">Sine Sweep (20Hz-20kHz)</option>
                    <option value="pink">Pink Noise</option>
                    <option value="white">White Noise</option>
                    <option value="impulse">Impulse (MLS)</option>
                    <option value="chirp">Chirp Signal</option>
                </select>
                <input type="number" id="duration" value="3" min="1" max="10" step="0.5">
                <label style="font-size: 0.9em; color: #666;">Duration (seconds)</label>
            </div>
            
            <div class="control-group">
                <h3>üéöÔ∏è Output Configuration</h3>
                <select id="outputChannel">
                    <option value="both">Both Sets (A+B)</option>
                    <option value="setA">Set A Only (Front)</option>
                    <option value="setB">Set B Only (Side/Back)</option>
                </select>
                <input type="range" id="volume" min="0" max="100" value="50">
                <label style="font-size: 0.9em; color: #666;">Volume: <span id="volumeLabel">50%</span></label>
            </div>
            
            <div class="control-group">
                <h3>üéØ Measurement Mode</h3>
                <select id="measurementMode">
                    <option value="all">All Parameters</option>
                    <option value="rt60">RT60 Only</option>
                    <option value="comb">Comb Filtering Only</option>
                    <option value="delay">Time Delay Only</option>
                </select>
                <button id="calibrateBtn">Calibrate Background Noise</button>
            </div>
        </div>
        
        <div class="control-group" style="text-align: center;">
            <button id="startBtn" style="font-size: 1.2em; padding: 15px;">
                üé§ Start Measurement
            </button>
            <button id="stopBtn" style="font-size: 1.2em; padding: 15px;" disabled>
                ‚èπÔ∏è Stop
            </button>
        </div>
        
        <div id="status" class="status">Ready to measure</div>
        
        <div class="results">
            <div class="result-card">
                <h4>
                    <span class="icon">‚è±Ô∏è</span>
                    RT60 Reverberation Time
                </h4>
                <div class="result-value" id="rt60Value">--</div>
                <canvas id="rt60Canvas"></canvas>
                <div class="result-details">
                    <strong>Frequency Bands:</strong><br>
                    125 Hz: <span id="rt60_125">--</span><br>
                    250 Hz: <span id="rt60_250">--</span><br>
                    500 Hz: <span id="rt60_500">--</span><br>
                    1 kHz: <span id="rt60_1k">--</span><br>
                    2 kHz: <span id="rt60_2k">--</span><br>
                    4 kHz: <span id="rt60_4k">--</span>
                </div>
            </div>
            
            <div class="result-card">
                <h4>
                    <span class="icon">üìä</span>
                    Comb Filtering Analysis
                </h4>
                <div class="result-value" id="combValue">--</div>
                <canvas id="combCanvas"></canvas>
                <div class="result-details">
                    <strong>Detected Notches:</strong><br>
                    <div id="combNotches">No data yet</div>
                    <br>
                    <strong>Severity Index:</strong> <span id="combSeverity">--</span><br>
                    <strong>Affected Range:</strong> <span id="combRange">--</span>
                </div>
            </div>
            
            <div class="result-card">
                <h4>
                    <span class="icon">‚è∞</span>
                    Time Delay Measurement
                </h4>
                <div class="result-value" id="delayValue">-- ms</div>
                <canvas id="delayCanvas"></canvas>
                <div class="result-details">
                    <strong>Set A ‚Üí Set B:</strong> <span id="delayAB">--</span> ms<br>
                    <strong>Distance Equivalent:</strong> <span id="delayDistance">--</span> m<br>
                    <strong>Phase Alignment:</strong> <span id="phaseAlign">--</span><br>
                    <strong>Haas Zone:</strong> <span id="haasZone">--</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class AcousticMeasurementTool {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isRecording = false;
                this.recordedData = [];
                this.sampleRate = 48000;
                this.backgroundNoise = null;
                
                this.initializeUI();
            }
            
            initializeUI() {
                document.getElementById('startBtn').addEventListener('click', () => this.startMeasurement());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopMeasurement());
                document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrateNoise());
                document.getElementById('volume').addEventListener('input', (e) => {
                    document.getElementById('volumeLabel').textContent = e.target.value + '%';
                });
            }
            
            async initAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: this.sampleRate });
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 4096;
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyser);
                    return true;
                } catch (error) {
                    console.error('Microphone access denied:', error);
                    this.updateStatus('Microphone access denied. Please allow microphone access.', 'error');
                    return false;
                }
            }
            
            generateTestSignal(type, duration) {
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(2, length, sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    
                    switch(type) {
                        case 'sweep':
                            this.generateSineSweep(channelData, 20, 20000, duration);
                            break;
                        case 'pink':
                            this.generatePinkNoise(channelData);
                            break;
                        case 'white':
                            this.generateWhiteNoise(channelData);
                            break;
                        case 'impulse':
                            this.generateMLS(channelData);
                            break;
                        case 'chirp':
                            this.generateChirp(channelData, 20, 20000, duration);
                            break;
                    }
                }
                
                return buffer;
            }
            
            generateSineSweep(data, startFreq, endFreq, duration) {
                const sampleRate = this.audioContext.sampleRate;
                const k = Math.pow(endFreq / startFreq, 1 / (data.length - 1));
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    const freq = startFreq * Math.pow(k, i);
                    const phase = 2 * Math.PI * freq * t;
                    data[i] = Math.sin(phase) * 0.8;
                }
            }
            
            generatePinkNoise(data) {
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const white = Math.random() * 2 - 1;
                    
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }
            }
            
            generateWhiteNoise(data) {
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3;
                }
            }
            
            generateMLS(data) {
                // Maximum Length Sequence for impulse response measurement
                const n = 15; // 2^15 - 1 length
                const length = Math.pow(2, n) - 1;
                const mls = new Array(length);
                
                // Initialize shift register
                let sr = 1;
                for (let i = 0; i < length; i++) {
                    mls[i] = (sr & 1) ? 1 : -1;
                    const newBit = ((sr >> 14) ^ (sr >> 13)) & 1;
                    sr = (sr >> 1) | (newBit << 14);
                }
                
                // Fill buffer with repeated MLS
                for (let i = 0; i < data.length; i++) {
                    data[i] = mls[i % length] * 0.5;
                }
            }
            
            generateChirp(data, startFreq, endFreq, duration) {
                const sampleRate = this.audioContext.sampleRate;
                const k = (endFreq - startFreq) / duration;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    const freq = startFreq + k * t;
                    const phase = 2 * Math.PI * (startFreq * t + k * t * t / 2);
                    data[i] = Math.sin(phase) * 0.8;
                }
            }
            
            async startMeasurement() {
                if (!this.audioContext) {
                    const success = await this.initAudio();
                    if (!success) return;
                }
                
                this.updateStatus('Generating test signal...', 'info');
                
                const signalType = document.getElementById('signalType').value;
                const duration = parseFloat(document.getElementById('duration').value);
                const volume = document.getElementById('volume').value / 100;
                
                // Generate and play test signal
                const testSignal = this.generateTestSignal(signalType, duration);
                const source = this.audioContext.createBufferSource();
                source.buffer = testSignal;
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Start recording
                this.startRecording();
                
                // Play signal
                source.start();
                
                this.updateStatus('Recording... Please wait ' + duration + ' seconds', 'recording');
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                // Auto-stop after duration + 2 seconds (for reverb tail)
                setTimeout(() => {
                    this.stopMeasurement();
                }, (duration + 2) * 1000);
            }
            
            startRecording() {
                this.isRecording = true;
                this.recordedData = [];
                
                const scriptProcessor = this.audioContext.createScriptProcessor(4096, 1, 1);
                this.microphone.connect(scriptProcessor);
                scriptProcessor.connect(this.audioContext.destination);
                
                scriptProcessor.onaudioprocess = (e) => {
                    if (!this.isRecording) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    this.recordedData.push(...inputData);
                };
                
                this.scriptProcessor = scriptProcessor;
            }
            
            stopMeasurement() {
                this.isRecording = false;
                
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                    this.microphone.disconnect(this.scriptProcessor);
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                this.updateStatus('Processing measurements...', 'processing');
                
                // Process recorded data
                setTimeout(() => {
                    this.processRecording();
                }, 100);
            }
            
            processRecording() {
                if (this.recordedData.length === 0) {
                    this.updateStatus('No data recorded', 'error');
                    return;
                }
                
                const mode = document.getElementById('measurementMode').value;
                
                if (mode === 'all' || mode === 'rt60') {
                    this.measureRT60();
                }
                
                if (mode === 'all' || mode === 'comb') {
                    this.measureCombFiltering();
                }
                
                if (mode === 'all' || mode === 'delay') {
                    this.measureTimeDelay();
                }
                
                this.updateStatus('Measurement complete', 'success');
            }
            
            measureRT60() {
                // Schroeder reverse integration method for RT60
                const data = this.recordedData;
                const sampleRate = this.audioContext.sampleRate;
                
                // Calculate energy decay curve
                const energyDecay = [];
                for (let i = 0; i < data.length; i++) {
                    energyDecay[i] = data[i] * data[i];
                }
                
                // Reverse integrate
                const reverseIntegral = [];
                let sum = 0;
                for (let i = data.length - 1; i >= 0; i--) {
                    sum += energyDecay[i];
                    reverseIntegral[i] = sum;
                }
                
                // Convert to dB
                const maxEnergy = Math.max(...reverseIntegral);
                const decayDB = reverseIntegral.map(e => 10 * Math.log10(e / maxEnergy));
                
                // Find -5dB and -35dB points for RT30 calculation
                let t5 = 0, t35 = 0;
                for (let i = 0; i < decayDB.length; i++) {
                    if (decayDB[i] <= -5 && t5 === 0) t5 = i / sampleRate;
                    if (decayDB[i] <= -35 && t35 === 0) {
                        t35 = i / sampleRate;
                        break;
                    }
                }
                
                // Calculate RT60 from RT30
                const rt30 = t35 - t5;
                const rt60 = rt30 * 2;
                
                // Update display
                document.getElementById('rt60Value').textContent = rt60.toFixed(2) + ' s';
                
                // Calculate frequency-dependent RT60
                this.calculateFrequencyRT60(data);
                
                // Draw decay curve
                this.drawDecayCurve(decayDB);
            }
            
            calculateFrequencyRT60(data) {
                const bands = [125, 250, 500, 1000, 2000, 4000];
                const sampleRate = this.audioContext.sampleRate;
                
                bands.forEach(freq => {
                    // Apply bandpass filter
                    const filtered = this.bandpassFilter(data, freq, sampleRate);
                    
                    // Calculate RT60 for this band
                    const rt60 = this.calculateBandRT60(filtered, sampleRate);
                    
                    // Update display
                    const id = freq >= 1000 ? `rt60_${freq/1000}k` : `rt60_${freq}`;
                    document.getElementById(id).textContent = rt60.toFixed(2) + ' s';
                });
            }
            
            bandpassFilter(data, centerFreq, sampleRate) {
                // Simple Butterworth bandpass filter
                const nyquist = sampleRate / 2;
                const low = centerFreq / Math.sqrt(2);
                const high = centerFreq * Math.sqrt(2);
                
                const lowCutoff = low / nyquist;
                const highCutoff = high / nyquist;
                
                // Filter coefficients (simplified)
                const filtered = [];
                for (let i = 2; i < data.length; i++) {
                    filtered[i] = data[i] * 0.5 + data[i-1] * 0.3 + data[i-2] * 0.2;
                }
                
                return filtered;
            }
            
            calculateBandRT60(data, sampleRate) {
                // Similar to main RT60 calculation but for filtered data
                const energyDecay = data.map(x => x * x);
                
                const reverseIntegral = [];
                let sum = 0;
                for (let i = data.length - 1; i >= 0; i--) {
                    sum += energyDecay[i];
                    reverseIntegral[i] = sum;
                }
                
                const maxEnergy = Math.max(...reverseIntegral.filter(x => x > 0));
                const decayDB = reverseIntegral.map(e => e > 0 ? 10 * Math.log10(e / maxEnergy) : -60);
                
                let t5 = 0, t35 = 0;
                for (let i = 0; i < decayDB.length; i++) {
                    if (decayDB[i] <= -5 && t5 === 0) t5 = i / sampleRate;
                    if (decayDB[i] <= -35 && t35 === 0) {
                        t35 = i / sampleRate;
                        break;
                    }
                }
                
                return (t35 - t5) * 2;
            }
            
            measureCombFiltering() {
                // FFT analysis to detect comb filtering
                const fftSize = 8192;
                const fft = this.performFFT(this.recordedData, fftSize);
                
                // Convert to magnitude spectrum in dB
                const magnitudeDB = fft.map(x => 20 * Math.log10(Math.abs(x) + 1e-10));
                
                // Find notches (local minima)
                const notches = [];
                for (let i = 10; i < magnitudeDB.length - 10; i++) {
                    if (magnitudeDB[i] < magnitudeDB[i-1] && 
                        magnitudeDB[i] < magnitudeDB[i+1] &&
                        magnitudeDB[i] < magnitudeDB[i-5] &&
                        magnitudeDB[i] < magnitudeDB[i+5]) {
                        
                        const freq = (i * this.audioContext.sampleRate) / fftSize;
                        const depth = Math.max(...magnitudeDB.slice(i-10, i+10)) - magnitudeDB[i];
                        
                        if (depth > 6) { // Only significant notches
                            notches.push({ freq: freq, depth: depth });
                        }
                    }
                }
                
                // Calculate comb filter period from notch spacing
                if (notches.length >= 2) {
                    const spacing = notches[1].freq - notches[0].freq;
                    const delay = 1000 / spacing; // Convert to ms
                    
                    document.getElementById('combValue').textContent = delay.toFixed(1) + ' ms period';
                } else {
                    document.getElementById('combValue').textContent = 'No comb filtering detected';
                }
                
                // Update notch list
                const notchList = notches.slice(0, 5).map(n => 
                    `${n.freq.toFixed(0)} Hz (-${n.depth.toFixed(1)} dB)`
                ).join('<br>');
                document.getElementById('combNotches').innerHTML = notchList || 'None detected';
                
                // Calculate severity
                const avgDepth = notches.reduce((sum, n) => sum + n.depth, 0) / (notches.length || 1);
                const severity = avgDepth > 15 ? 'Severe' : avgDepth > 10 ? 'Moderate' : avgDepth > 5 ? 'Mild' : 'None';
                document.getElementById('combSeverity').textContent = severity;
                
                // Affected frequency range
                if (notches.length > 0) {
                    const minFreq = Math.min(...notches.map(n => n.freq));
                    const maxFreq = Math.max(...notches.map(n => n.freq));
                    document.getElementById('combRange').textContent = `${minFreq.toFixed(0)} - ${maxFreq.toFixed(0)} Hz`;
                } else {
                    document.getElementById('combRange').textContent = 'N/A';
                }
                
                // Draw spectrum
                this.drawSpectrum(magnitudeDB, notches);
            }
            
            performFFT(data, fftSize) {
                // Simple DFT implementation (would use Web Audio API FFT in production)
                const fft = [];
                const N = Math.min(data.length, fftSize);
                
                for (let k = 0; k < N/2; k++) {
                    let real = 0, imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += data[n] * Math.cos(angle);
                        imag += data[n] * Math.sin(angle);
                    }
                    
                    fft[k] = { real: real/N, imag: imag/N };
                }
                
                return fft;
            }
            
            measureTimeDelay() {
                // Cross-correlation to find delay between direct and reflected sound
                const data = this.recordedData;
                const sampleRate = this.audioContext.sampleRate;
                
                // Find peak (direct sound)
                let maxVal = 0, maxIdx = 0;
                for (let i = 0; i < data.length / 2; i++) {
                    if (Math.abs(data[i]) > maxVal) {
                        maxVal = Math.abs(data[i]);
                        maxIdx = i;
                    }
                }
                
                // Find secondary peak (reflection)
                let secondMaxVal = 0, secondMaxIdx = 0;
                for (let i = maxIdx + sampleRate * 0.001; i < data.length; i++) {
                    if (Math.abs(data[i]) > secondMaxVal && i > maxIdx + 100) {
                        secondMaxVal = Math.abs(data[i]);
                        secondMaxIdx = i;
                    }
                }
                
                // Calculate delay
                const delaySamples = secondMaxIdx - maxIdx;
                const delayMs = (delaySamples / sampleRate) * 1000;
                
                document.getElementById('delayValue').textContent = delayMs.toFixed(1) + ' ms';
                document.getElementById('delayAB').textContent = delayMs.toFixed(1);
                
                // Calculate distance
                const speedOfSound = 343; // m/s at room temperature
                const distance = (delayMs / 1000) * speedOfSound;
                document.getElementById('delayDistance').textContent = distance.toFixed(2);
                
                // Phase alignment check
                const phaseShift = (delayMs * 1000) % 360;
                document.getElementById('phaseAlign').textContent = phaseShift.toFixed(0) + '¬∞';
                
                // Haas effect zone check
                let haasZone;
                if (delayMs < 1) {
                    haasZone = 'Summing (constructive/destructive)';
                } else if (delayMs < 35) {
                    haasZone = 'Haas effect (precedence)';
                } else if (delayMs < 50) {
                    haasZone = 'Ambiguous localization';
                } else {
                    haasZone = 'Distinct echo';
                }
                document.getElementById('haasZone').textContent = haasZone;
                
                // Draw impulse response
                this.drawImpulseResponse(data, maxIdx, secondMaxIdx);
            }
            
            drawDecayCurve(decayDB) {
                const canvas = document.getElementById('rt60Canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 6; i++) {
                    const y = (i * canvas.height) / 6;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw decay curve
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const step = Math.floor(decayDB.length / canvas.width);
                for (let x = 0; x < canvas.width; x++) {
                    const idx = x * step;
                    const y = ((-decayDB[idx] / 60) * canvas.height);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw -5dB and -35dB markers
                ctx.strokeStyle = '#ff6b6b';
                ctx.setLineDash([5, 5]);
                
                const y5 = (5 / 60) * canvas.height;
                const y35 = (35 / 60) * canvas.height;
                
                ctx.beginPath();
                ctx.moveTo(0, y5);
                ctx.lineTo(canvas.width, y5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, y35);
                ctx.lineTo(canvas.width, y35);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            drawSpectrum(magnitudeDB, notches) {
                const canvas = document.getElementById('combCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Find min and max for scaling
                const validMags = magnitudeDB.filter(x => x > -100 && x < 100);
                const minDB = Math.min(...validMags);
                const maxDB = Math.max(...validMags);
                const range = maxDB - minDB;
                
                // Draw frequency spectrum
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                const step = Math.floor(magnitudeDB.length / canvas.width);
                for (let x = 0; x < canvas.width; x++) {
                    const idx = Math.min(x * step, magnitudeDB.length - 1);
                    const y = canvas.height - ((magnitudeDB[idx] - minDB) / range) * canvas.height;
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Mark notches
                ctx.fillStyle = '#ff6b6b';
                notches.forEach(notch => {
                    const x = (notch.freq / (this.audioContext.sampleRate / 2)) * canvas.width;
                    ctx.beginPath();
                    ctx.arc(x, canvas.height * 0.8, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            drawImpulseResponse(data, directIdx, reflectionIdx) {
                const canvas = document.getElementById('delayCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = 200;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Determine display range
                const displayStart = Math.max(0, directIdx - 1000);
                const displayEnd = Math.min(data.length, reflectionIdx + 1000);
                const displayLength = displayEnd - displayStart;
                
                // Draw waveform
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const step = Math.floor(displayLength / canvas.width);
                for (let x = 0; x < canvas.width; x++) {
                    const idx = displayStart + (x * step);
                    const y = (canvas.height / 2) - (data[idx] * canvas.height / 2);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Mark direct sound
                const directX = ((directIdx - displayStart) / displayLength) * canvas.width;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(directX, 0);
                ctx.lineTo(directX, canvas.height);
                ctx.stroke();
                
                // Mark reflection
                const reflectionX = ((reflectionIdx - displayStart) / displayLength) * canvas.width;
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(reflectionX, 0);
                ctx.lineTo(reflectionX, canvas.height);
                ctx.stroke();
                
                // Add labels
                ctx.font = '12px Arial';
                ctx.fillStyle = '#4CAF50';
                ctx.fillText('Direct', directX + 5, 20);
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText('Reflection', reflectionX + 5, 20);
            }
            
            async calibrateNoise() {
                if (!this.audioContext) {
                    const success = await this.initAudio();
                    if (!success) return;
                }
                
                this.updateStatus('Calibrating background noise... Keep quiet for 3 seconds', 'calibrating');
                
                const calibrationData = [];
                const duration = 3000; // 3 seconds
                const startTime = Date.now();
                
                const scriptProcessor = this.audioContext.createScriptProcessor(4096, 1, 1);
                this.microphone.connect(scriptProcessor);
                scriptProcessor.connect(this.audioContext.destination);
                
                scriptProcessor.onaudioprocess = (e) => {
                    if (Date.now() - startTime < duration) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        calibrationData.push(...inputData);
                    } else {
                        scriptProcessor.disconnect();
                        this.microphone.disconnect(scriptProcessor);
                        
                        // Calculate noise floor
                        const rms = Math.sqrt(calibrationData.reduce((sum, x) => sum + x * x, 0) / calibrationData.length);
                        this.backgroundNoise = rms;
                        
                        const noiseDB = 20 * Math.log10(rms);
                        this.updateStatus(`Noise floor calibrated: ${noiseDB.toFixed(1)} dB`, 'success');
                    }
                };
            }
            
            updateStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                
                // Update status color based on type
                const colors = {
                    'info': '#0066cc',
                    'success': '#28a745',
                    'error': '#dc3545',
                    'warning': '#ffc107',
                    'recording': '#ff6b6b',
                    'processing': '#667eea',
                    'calibrating': '#17a2b8'
                };
                
                statusEl.style.background = colors[type] ? `${colors[type]}15` : '#e8f4f8';
                statusEl.style.color = colors[type] || '#0066cc';
            }
        }
        
        // Initialize the tool when page loads
        let measurementTool;
        document.addEventListener('DOMContentLoaded', () => {
            measurementTool = new AcousticMeasurementTool();
        });