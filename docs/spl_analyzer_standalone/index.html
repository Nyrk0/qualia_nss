<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRD File Viewer and Grapher</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
        }
        canvas {
            border: 1px solid #e5e7eb;
            background-color: #f9fafb;
            cursor: crosshair;
            touch-action: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-6 md:p-8 rounded-xl shadow-lg w-full max-w-2xl">
        <h1 class="text-xl md:text-2xl font-bold text-gray-800 mb-0 text-center">QUALIA â€¢ NSS SPL Viewer</h1>
        <p class="text-gray-600 mb-4 text-center text-xs md:text-sm">7-band psychoacoustic</p>
        
        <!-- File input -->
        <div class="mb-4 md:mb-6">
            <label for="frdFile" class="block text-sm font-medium text-gray-700">Upload an FRD file to visualize its frequency response data.</label>
            <input type="file" id="frdFile" accept=".frd" class="mt-1 block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-lg file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100">
        </div>

        <!-- Canvas for the graph -->
        <!-- The height is now dynamic (h-[60vh] instead of fixed pixels) for better responsiveness -->
        <div class="flex items-center justify-center relative w-full h-[60vh] max-w-full">
            <canvas id="splCanvas" class="w-full h-full rounded-lg"></canvas>
            <div id="tooltip" class="absolute hidden px-2 py-1 bg-gray-800 text-white text-xs rounded-lg shadow-lg pointer-events-none"></div>
        </div>

        <!-- Status/Error message area -->
        <div id="status" class="mt-4 text-sm text-gray-500 text-center">Please select a file to begin.</div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get references to DOM elements
            const fileInput = document.getElementById('frdFile');
            const canvas = document.getElementById('splCanvas');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');
            const tooltip = document.getElementById('tooltip');

            let rawData = [];

            // Listen for file selection
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    statusDiv.textContent = 'No file selected.';
                    return;
                }

                statusDiv.textContent = `Processing file: ${file.name}...`;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const fileContent = e.target.result;
                        rawData = parseFrdFile(fileContent);
                        if (rawData.length > 0) {
                            statusDiv.textContent = `Successfully loaded data, enjoy!`;
                            drawGraph();
                        } else {
                            statusDiv.textContent = 'Error: No valid data found in the file.';
                            clearCanvas();
                        }
                    } catch (error) {
                        statusDiv.textContent = `Error: Failed to parse file. ${error.message}`;
                        clearCanvas();
                        console.error('Parsing error:', error);
                    }
                };
                reader.onerror = () => {
                    statusDiv.textContent = 'Error: Failed to read file.';
                    console.error('File reading error:', reader.error);
                };
                reader.readAsText(file);
            });

            // Parse FRD file content
            function parseFrdFile(content) {
                const lines = content.split('\n');
                const data = [];
                const freqUnitMatch = /Hz/.test(content);
                const dbUnitMatch = /dB/.test(content);

                for (const line of lines) {
                    // Ignore comment lines (starting with #, !, or *)
                    if (line.trim().startsWith('#') || line.trim().startsWith('!') || line.trim().startsWith('*')) {
                        continue;
                    }

                    // Split the line by whitespace or commas
                    const parts = line.trim().split(/[\s,]+/).filter(Boolean);
                    if (parts.length >= 2) {
                        const frequency = parseFloat(parts[0]);
                        const db = parseFloat(parts[1]);

                        if (!isNaN(frequency) && !isNaN(db)) {
                            data.push({ frequency, db });
                        }
                    }
                }
                return data;
            }

            // Draw the graph on the canvas
            function drawGraph() {
                if (rawData.length === 0) {
                    clearCanvas();
                    return;
                }
                
                // Set canvas size and resolution
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                const padding = 40;
                const plotWidth = canvas.width - 2 * padding;
                const plotHeight = canvas.height - 2 * padding;

                // Get min/max values for scaling
                const freqs = rawData.map(d => d.frequency);
                const minFreq = Math.min(...freqs);
                const maxFreq = Math.max(...freqs);

                // Define fixed Y-axis range
                const plotMinDb = 50;
                const plotMaxDb = 100;

                clearCanvas();
                
                // --- Drawing logic ---
                
                // Psychoacoustic bands definition
                const bands = [
                    { name: "Sub-bass", min: 20, max: 60, color: 'rgba(255, 99, 132, 0.2)' },
                    { name: "Bass", min: 60, max: 250, color: 'rgba(54, 162, 235, 0.2)' },
                    { name: "Low Midrange", min: 250, max: 500, color: 'rgba(255, 206, 86, 0.2)' },
                    { name: "Midrange", min: 500, max: 2000, color: 'rgba(75, 192, 192, 0.2)' },
                    { name: "Upper Midrange", min: 2000, max: 4000, color: 'rgba(153, 102, 255, 0.2)' },
                    { name: "Presence", min: 4000, max: 6000, color: 'rgba(255, 159, 64, 0.2)' },
                    { name: "Brilliance", min: 6000, max: 20000, color: 'rgba(201, 203, 207, 0.2)' },
                ];

                // Logarithmic frequency scale for x-axis. Use 20Hz and 20kHz as a fixed bound.
                const logMinFreq = Math.log10(Math.min(20, minFreq));
                const logMaxFreq = Math.log10(Math.max(20000, maxFreq));

                // Function to convert frequency to canvas x coordinate
                const freqToX = (freq) => {
                    if (freq <= 0) return 0; // Avoid log(0)
                    const logFreq = Math.log10(freq);
                    return padding + plotWidth * (logFreq - logMinFreq) / (logMaxFreq - logMinFreq);
                };

                // Draw the colored psychoacoustic bands
                for (const band of bands) {
                    if (band.min < maxFreq && band.max > minFreq) {
                        const xStart = freqToX(Math.max(band.min, minFreq));
                        const xEnd = freqToX(Math.min(band.max, maxFreq));
                        ctx.fillStyle = band.color;
                        ctx.fillRect(xStart, padding, xEnd - xStart, plotHeight);
                        
                        // Add band name label at the bottom
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '10px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(band.name, (xStart + xEnd) / 2, canvas.height - padding + 5);
                    }
                }
                
                // Draw grid and labels on top of the bands
                ctx.strokeStyle = '#d1d5db';
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw vertical grid lines and frequency labels (log scale) - only at band limits
                const majorTicks = [20, 60, 250, 500, 2000, 4000, 6000, 20000];
                
                for (const tick of majorTicks) {
                    const x = freqToX(tick);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, canvas.height - padding);
                    ctx.stroke();
                    ctx.fillText(tick.toString().replace('000', 'k'), x, canvas.height - padding / 2);
                }
                
                // Draw horizontal grid lines and dB labels
                const dbTicks = [50, 60, 70, 80, 90, 100];
                const minorDbTicks = [];
                for (let i = plotMinDb; i <= plotMaxDb; i++) {
                    if (i % 10 !== 0) {
                        minorDbTicks.push(i);
                    }
                }

                // Draw minor dashed horizontal lines
                ctx.strokeStyle = '#e5e7eb';
                ctx.setLineDash([2, 5]); // Set dashed line pattern
                for (const db of minorDbTicks) {
                    const y = padding + plotHeight * (1 - (db - plotMinDb) / (plotMaxDb - plotMinDb));
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                }

                // Draw major solid horizontal lines
                ctx.setLineDash([]); // Reset to solid line
                ctx.strokeStyle = '#d1d5db';
                for (const db of dbTicks) {
                    const y = padding + plotHeight * (1 - (db - plotMinDb) / (plotMaxDb - plotMinDb));
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                    ctx.textAlign = 'right';
                    ctx.fillText(db.toFixed(0), padding - 10, y);
                }

                // Draw axis labels
                ctx.textAlign = 'center';
                ctx.fillText('Frequency [Hz]', canvas.width / 2, canvas.height - 10);
                ctx.save();
                ctx.translate(padding / 2, canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('SPL [dB]', 0, 0);
                ctx.restore();

                // Draw the data line
                ctx.beginPath();
                ctx.strokeStyle = '#ef4444'; // Red line for the graph
                ctx.lineWidth = 2;
                rawData.forEach((point, index) => {
                    const x = freqToX(point.frequency);
                    const y = padding + plotHeight * (1 - (point.db - plotMinDb) / (plotMaxDb - plotMinDb));
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }

            // Clear the canvas
            function clearCanvas() {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Handle window resize to redraw the canvas
            window.addEventListener('resize', () => {
                if (rawData.length > 0) {
                    drawGraph();
                } else {
                    clearCanvas();
                }
            });

            // Handle mouse movement for tooltip
            canvas.addEventListener('mousemove', (e) => {
                if (rawData.length === 0) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const padding = 40;
                const plotWidth = canvas.width - 2 * padding;
                const plotHeight = canvas.height - 2 * padding;

                const logMinFreq = Math.log10(Math.min(...rawData.map(d => d.frequency)));
                const logMaxFreq = Math.log10(Math.max(...rawData.map(d => d.frequency)));
                const minDb = 50;
                const maxDb = 100;

                // Find the closest data point
                const closestPoint = rawData.reduce((prev, curr) => {
                    const logFreq = Math.log10(curr.frequency);
                    const x = padding + plotWidth * (logFreq - logMinFreq) / (logMaxFreq - logMinFreq);
                    return (Math.abs(x - mouseX) < Math.abs(prev.x - mouseX) ? { ...curr, x } : prev);
                }, { x: Infinity });
                
                if (closestPoint.frequency) {
                    const y = padding + plotHeight * (1 - (closestPoint.db - minDb) / (maxDb - minDb));

                    // Show tooltip
                    tooltip.style.display = 'block';
                    tooltip.textContent = `Freq: ${closestPoint.frequency.toFixed(1)} Hz, dB: ${closestPoint.db.toFixed(1)}`;
                    
                    // Position tooltip
                    let tooltipX = closestPoint.x + rect.left + 15;
                    let tooltipY = y + rect.top - 15;
                    
                    // Keep tooltip within bounds
                    if (tooltipX + tooltip.offsetWidth > window.innerWidth) {
                        tooltipX = closestPoint.x + rect.left - tooltip.offsetWidth - 15;
                    }
                    if (tooltipY < 0) {
                         tooltipY = y + rect.top + 15;
                    }

                    tooltip.style.left = `${tooltipX}px`;
                    tooltip.style.top = `${tooltipY}px`;
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        });
    </script>
</body>
</html>